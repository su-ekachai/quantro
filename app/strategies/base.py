"""
Base strategy interface and models for the Quantro trading platform.

This module defines the abstract base class for all trading strategies,
along with the data models for strategy configuration and signals.
"""

from __future__ import annotations

from abc import ABC, abstractmethod
from datetime import datetime
from enum import Enum
from typing import Any

from pydantic import BaseModel, Field, field_validator


class SignalType(str, Enum):
    """Enumeration of possible signal types."""

    BUY = "buy"
    SELL = "sell"
    HOLD = "hold"


class Timeframe(str, Enum):
    """Supported timeframes for strategy execution."""

    ONE_MINUTE = "1m"
    FIVE_MINUTES = "5m"
    FIFTEEN_MINUTES = "15m"
    ONE_HOUR = "1h"
    FOUR_HOURS = "4h"
    ONE_DAY = "1d"


class StrategyConfig(BaseModel):
    """Configuration model for trading strategies."""

    name: str = Field(..., description="Strategy name")
    timeframes: list[Timeframe] = Field(
        default=[Timeframe.ONE_HOUR],
        description="List of timeframes to run strategy on",
    )
    parameters: dict[str, Any] = Field(
        default_factory=dict, description="Strategy-specific parameters"
    )
    enabled: bool = Field(default=True, description="Whether strategy is enabled")
    max_positions: int = Field(
        default=1, ge=1, description="Maximum number of concurrent positions"
    )
    risk_per_trade: float = Field(
        default=0.02, ge=0.001, le=0.1, description="Risk per trade as percentage"
    )

    @field_validator("timeframes")
    @classmethod
    def validate_timeframes(cls, v: list[Timeframe]) -> list[Timeframe]:
        """Validate that at least one timeframe is provided."""
        if not v:
            raise ValueError("At least one timeframe must be specified")
        return v

    @field_validator("name")
    @classmethod
    def validate_name(cls, v: str) -> str:
        """Validate strategy name is not empty."""
        if not v.strip():
            raise ValueError("Strategy name cannot be empty")
        return v.strip()


class Signal(BaseModel):
    """Model representing a trading signal generated by a strategy."""

    signal_type: SignalType = Field(..., description="Type of signal")
    confidence: float = Field(
        ..., ge=0.0, le=1.0, description="Confidence level (0.0 to 1.0)"
    )
    timestamp: datetime = Field(..., description="When the signal was generated")
    symbol: str = Field(..., description="Trading symbol")
    timeframe: Timeframe = Field(..., description="Timeframe used for signal")
    strategy_name: str = Field(
        ..., description="Name of strategy that generated signal"
    )
    price: float | None = Field(
        default=None, description="Current price when signal generated"
    )
    metadata: dict[str, Any] = Field(
        default_factory=dict, description="Additional signal metadata"
    )

    @field_validator("symbol")
    @classmethod
    def validate_symbol(cls, v: str) -> str:
        """Validate symbol is not empty."""
        if not v.strip():
            raise ValueError("Symbol cannot be empty")
        return v.strip().upper()

    @field_validator("strategy_name")
    @classmethod
    def validate_strategy_name(cls, v: str) -> str:
        """Validate strategy name is not empty."""
        if not v.strip():
            raise ValueError("Strategy name cannot be empty")
        return v.strip()


class MarketData(BaseModel):
    """Market data model for strategy input."""

    symbol: str = Field(..., description="Trading symbol")
    timestamp: datetime = Field(..., description="Data timestamp")
    open: float = Field(..., description="Opening price")
    high: float = Field(..., description="High price")
    low: float = Field(..., description="Low price")
    close: float = Field(..., description="Closing price")
    volume: float = Field(..., description="Trading volume")
    timeframe: Timeframe = Field(..., description="Data timeframe")

    @field_validator("symbol")
    @classmethod
    def validate_symbol(cls, v: str) -> str:
        """Validate symbol is not empty."""
        if not v.strip():
            raise ValueError("Symbol cannot be empty")
        return v.strip().upper()

    @field_validator("open", "high", "low", "close")
    @classmethod
    def validate_prices(cls, v: float) -> float:
        """Validate prices are positive."""
        if v <= 0:
            raise ValueError("Prices must be positive")
        return v

    @field_validator("volume")
    @classmethod
    def validate_volume(cls, v: float) -> float:
        """Validate volume is non-negative."""
        if v < 0:
            raise ValueError("Volume must be non-negative")
        return v


class IStrategy(ABC):
    """
    Abstract base class for all trading strategies.

    All strategies must inherit from this class and implement the required methods.
    This ensures a consistent interface for strategy execution and management.
    """

    def __init__(self, config: StrategyConfig) -> None:
        """
        Initialize the strategy with configuration.

        Args:
            config: Strategy configuration containing parameters and settings
        """
        self.config = config
        self._initialized = False

    @property
    def name(self) -> str:
        """Get the strategy name."""
        return self.config.name

    @property
    def timeframes(self) -> list[Timeframe]:
        """Get the supported timeframes."""
        return self.config.timeframes

    @property
    def is_initialized(self) -> bool:
        """Check if strategy has been initialized."""
        return self._initialized

    @abstractmethod
    async def initialize(self) -> None:
        """
        Initialize the strategy.

        This method is called once before the strategy starts generating signals.
        Use this to set up any required state, validate parameters, or prepare
        indicators.

        Raises:
            ValueError: If strategy parameters are invalid
            RuntimeError: If initialization fails
        """
        pass

    @abstractmethod
    async def generate_signal(self, data: MarketData) -> Signal | None:
        """
        Generate a trading signal based on market data.

        Args:
            data: Current market data for analysis

        Returns:
            Signal object if a signal is generated, None otherwise

        Raises:
            ValueError: If market data is invalid
            RuntimeError: If signal generation fails
        """
        pass

    @abstractmethod
    def validate_parameters(self, params: dict[str, Any]) -> bool:
        """
        Validate strategy-specific parameters.

        Args:
            params: Dictionary of parameters to validate

        Returns:
            True if parameters are valid, False otherwise
        """
        pass

    @abstractmethod
    def get_required_indicators(self) -> list[str]:
        """
        Get list of required technical indicators.

        Returns:
            List of indicator names required by this strategy
        """
        pass

    async def cleanup(self) -> None:
        """
        Clean up strategy resources.

        This method is called when the strategy is being stopped or removed.
        Override this method if your strategy needs to perform cleanup operations.
        """
        self._initialized = False

    def __str__(self) -> str:
        """String representation of the strategy."""
        return f"{self.__class__.__name__}(name='{self.name}')"

    def __repr__(self) -> str:
        """Detailed string representation of the strategy."""
        return (
            f"{self.__class__.__name__}("
            f"name='{self.name}', "
            f"timeframes={self.timeframes}, "
            f"initialized={self.is_initialized})"
        )
